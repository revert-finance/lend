// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./external/uniswap/v3-core/interfaces/IUniswapV3Factory.sol";
import "./external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol";

import "./external/compound/ComptrollerInterface.sol";
import "./external/compound/CToken.sol";

import "./V3Utils.sol";

contract NFTHolder is Ownable, IERC721Receiver  {

    uint32 constant public MAX_TOKENS_PER_ADDRESS = 100;

    address immutable public weth;

    // uniswap v3 components
    IUniswapV3Factory immutable public factory;
    INonfungiblePositionManager immutable public nonfungiblePositionManager;

    // compound components
    ComptrollerInterface immutable public comptroller;

    // TODO switchable?
    V3Utils immutable public v3Utils;

    // ISwapRouter maybe Uniswap or 1Inch or something else
    constructor(address _weth, IUniswapV3Factory _factory, INonfungiblePositionManager _nonfungiblePositionManager, V3Utils _v3Utils, ComptrollerInterface _comptroller) {
        weth = _weth;
        factory = _factory;
        nonfungiblePositionManager = _nonfungiblePositionManager;
        v3Utils = _v3Utils;
        comptroller = _comptroller;
    }

    // amount of position value which is payed from treasury for late in() / out() calls
    uint256 public punishmentFactor;

    struct PoolConfig {
        uint32 bufferZoneTicks;
        bool isActive;
        uint32 collateralFactor;
        address cToken0;
        address cToken1;
    }

    mapping(address => PoolConfig) poolConfigs;

    struct Token {
        address owner;
        uint128 originalLiquidity;
        address pool;

        bool isAutoCompoundable;
        bool isCollateralizable;
        bool isLendable;
        bool isStopLoss;

        // if not enough capital available for unlend() or if position was changed by owner in buffer zone
        bool isProtected;

         // if > 0 - lent out
        uint128 cTokenAmount;
        bool isCToken0;
    }

    mapping(uint256 => Token) tokens;
    mapping(address => uint256[]) public override accountTokens;
    mapping(address => mapping(address => uint256)) public override accountBalances;

    function onERC721Received(address, address from, uint256 tokenId, bytes data) external  {

        _addToken(tokenId, from);

        bool isAutoCompoundable; 
        bool isCollateralizable;
        bool isLendable;
        bool isStopLoss;

        (isAutoCompoundable, isCollateralizable, isLendable, isStopLoss) = abi.decode(data, (bool, bool, bool, bool));

        configToken(tokenId, isAutoCompoundable, isCollateralizable, isLendable, isStopLoss);

        return IERC721Receiver.onERC721Received.selector;
    }

    // sets tokens config flags - changes state when needed
    function configToken(uint tokenId, bool isAutoCompoundable, bool isCollateralizable, bool isLendable, bool isStopLoss) public {

        Token storage position = tokens[tokenId];

        require(position.owner == msg.sender, "!owned");

        PoolConfig storage poolConfig = poolConfigs[position.pool];

        if (position.isAutoCompoundable != isAutoCompoundable) {
            position.isAutoCompoundable = isAutoCompoundable;
        }

        if (position.isCollateralizable != isCollateralizable) {
            position.isCollateralizable = isCollateralizable;

            // if its removed from collateral - check if enough left
            if (!isCollateralizable) {
                // (Error err, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity()
            }
        }

        if (position.isLendable != isLendable) {
            position.isLendable = isLendable;
            bool isProtected;
            if (isLendable) {
                isProtected = lend(position);
            } else {
                isProtected = unlend(position);
            }
            position.isProtected = isProtected; // set flag depending in which position it was in
        }

        if (isStopLoss) {
            require(!isCollateralizable && !isLendable, "invalid stoploss config");
        }
        position.isStopLoss = isStopLoss;
    }

    function withdrawToken(
        uint256 tokenId,
        address to,
        bool withdrawBalances,
        bytes memory data
    ) external override nonReentrant {
        require(to != address(this), "to==this");

        Token storage token = tokens[tokenId];
        require(token.owner == msg.sender, "!owner");

        if (token.cTokenAmount > 0) {
            unlend(token);
        }

        _removeToken(tokenId, msg.sender);
        nonfungibleTokenManager.safeTransferFrom(address(this), to, tokenId, data);

        if (withdrawBalances) {
            (, , address token0, address token1, , , , , , , , ) = nonfungibleTokenManager.tokens(tokenId);
            _withdrawFullBalances(token0, token1, to);
        }
    }

    function balanceOf(address account) external view {
        return accountTokens[account].length;
    }

    function ownerOf(uint tokenId) external {
        return tokens[tokenId].owner;
    }
  

    // management method to be called when isLendable positions change from out of range towards in range
    function in(uint tokenId, bytes swapData) external {
        
        // if out of range - only owner or protocol can call this
        // if in range & !isProtected - anyone can call it
        // if in range & isProtected - only owner can call it

        // check if isLendable (only needed for these tokens)

        // unlend() or unlendWithSwap(swapData) if in range

        // can be called again when liquidity becomes available at a later moment

        // if !isProtected - pay position value * punishmentFactor
    }

    // management method to be called when isLendable positions change from in range towards out of range (and buffer zone)
    function out(uint tokenId) external {
        
        // if in range or buffer zone - only owner or protocol can call this
        // if out of range and buffer zone - anyone can call it


        // check if isLendable (only needed for these tokens)

        // lend()

        // if !isProtected - pay position value * punishmentFactor
    }

    // borrow tokens to be added to the position
    function borrow(uint tokenId, uint liquidity) external {

        // only owner

        // borrow needed tokens (without comptroller.checkCollateral() - flashloan style)

        // add liquidity or add ctokens (if in lent state)

        // comptroller.checkCollateral()
    }

    // repay tokens from the position
    function repay(uint tokenId, uint liquidity, bool swap) external {

        // only owner

        // remove liquidity

        // repay tokens - without swapping - needs to have enough debt in both tokens
        
        // comptroller.checkCollateral()
    }

    function autoCompound(uint tokenId) external {

        // require autocompounding is active

        // do autocompounding (optional with swap config - check swapped amounts to be min 99?% of swap amounts - check min added amount to position to be 80?%)

        // check if recieved tokens are enough using external oracle and check if big enough percentage was added to position

        // return part of protocol fees to caller

        // comptroller.checkCollateral()
    }

    function stopLoss(uint tokenId) external {
        
        // require stoploss is active

        // require position out of range

        // do stop loss - do collect and swap - and add tokens to internal balance

        // check if recieved tokens are enough using external oracle

        // return part of protocol fees to caller
    }

    function lend(Token storage token) internal {
        
        // must be out of range / must not have ctoken balance

        // remove all liquidity (one sided)
        // supply to ctoken
        // store in position token balance (ctoken balance)

        // comptroller.checkCollateral()
    }

    function unlend(Token storage token) internal {

        // must be out of range / must have ctoken balance

        // try to reedeem ctokens from position (without comptroller.checkCollateral() - flashloan style)
        // if not enough tokens available - set isProtectedFromPunishment - stop

        // add liquidity

        // comptroller.checkCollateral()
    }

    function unlendWithSwap(Token storage token, bytes data) internal {

        // must have ctoken balance
        // if !isProtected && in force zone - anyone can call this
        // if isProtected && in force zone - owner can call this

        // try to reedeem ctokens from position (without comptroller.checkCollateral() - flashloan style) - if not enough set to isProtected - stop

        // swap according to data
        // check if recieved token from swap are enough (slippage was respected) - as this can be called by anyone

        // add liquidity
        
        // if !isProtected - add from treasury missing tokens

        // comptroller.checkCollateral()
    }

    function _removeToken(uint256 tokenId, address account) internal {
        uint256[] memory accountTokensArr = accountTokens[account];
        uint256 len = accountTokensArr.length;
        uint256 assetIndex = len;

        // limited by MAX_POSITIONS_PER_ADDRESS (no out-of-gas problem)
        for (uint256 i = 0; i < len; i++) {
            if (accountTokensArr[i] == tokenId) {
                assetIndex = i;
                break;
            }
        }

        assert(assetIndex < len);

        uint256[] storage storedList = accountTokens[account];
        storedList[assetIndex] = storedList[storedList.length - 1];
        storedList.pop();

        delete tokens[tokenId];
    }
}